"""
Base Strategy Classes for Alpaca Improved

This module provides the foundational classes for implementing trading strategies
with comprehensive integration for Alpaca Trading API, risk management, and performance tracking.
"""

import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Union

import pandas as pd
from alpaca.trading import TradingClient
from alpaca.trading.requests import MarketOrderRequest, GetOrdersRequest
from alpaca.trading.enums import OrderSide, TimeInForce, OrderType
from alpaca.data import StockHistoricalDataClient
from alpaca.data.requests import StockBarsRequest
from alpaca.data.timeframe import TimeFrame

from ..config import Config, get_global_config
from ..utils.logger import get_logger, log_trade_event, log_strategy_performance


class StrategyState(Enum):
    """Strategy execution states."""
    INITIALIZED = "initialized"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    EXIT = "exit"


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy."""
    symbol: str
    signal_type: SignalType
    strength: float  # Signal strength from 0.0 to 1.0
    price: Optional[float] = None
    quantity: Optional[int] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Position:
    """Represents a trading position."""
    symbol: str
    quantity: float
    entry_price: float
    current_price: Optional[float] = None
    entry_time: datetime = field(default_factory=datetime.now)
    strategy: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def market_value(self) -> float:
        """Current market value of the position."""
        return (self.current_price or self.entry_price) * abs(self.quantity)
    
    @property
    def unrealized_pnl(self) -> float:
        """Unrealized profit and loss."""
        if self.current_price is None:
            return 0.0
        return (self.current_price - self.entry_price) * self.quantity
    
    @property
    def unrealized_pnl_percent(self) -> float:
        """Unrealized profit and loss as percentage."""
        if self.entry_price == 0:
            return 0.0
        return (self.unrealized_pnl / (self.entry_price * abs(self.quantity))) * 100


@dataclass
class StrategyConfig:
    """Configuration for strategy parameters."""
    name: str
    max_positions: int = 5
    position_size: float = 0.1  # Percentage of portfolio
    stop_loss: float = 0.05  # 5% stop loss
    take_profit: float = 0.15  # 15% take profit
    max_daily_trades: int = 10
    risk_per_trade: float = 0.02  # 2% risk per trade
    enable_stop_loss: bool = True
    enable_take_profit: bool = True
    trading_frequency: str = "daily"  # daily, intraday, weekly
    symbols: List[str] = field(default_factory=list)
    parameters: Dict[str, Any] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Base class for all trading strategies.
    
    This class provides the foundational structure and utilities for implementing
    trading strategies with Alpaca integration, risk management, and performance tracking.
    """
    
    def __init__(
        self,
        config: StrategyConfig,
        app_config: Optional[Config] = None,
        trading_client: Optional[TradingClient] = None,
        data_client: Optional[StockHistoricalDataClient] = None
    ):
        """
        Initialize the base strategy.
        
        Args:
            config: Strategy configuration
            app_config: Application configuration
            trading_client: Alpaca trading client
            data_client: Alpaca data client
        """
        self.config = config
        self.app_config = app_config or get_global_config()
        self.logger = get_logger(self.__class__.__name__)
        
        # Initialize Alpaca clients
        self.trading_client = trading_client or self._create_trading_client()
        self.data_client = data_client or self._create_data_client()
        
        # Strategy state
        self.state = StrategyState.INITIALIZED
        self.positions: Dict[str, Position] = {}
        self.daily_trades = 0
        self.last_trade_date = None
        
        # Performance tracking
        self.total_trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
        self.total_pnl = 0.0
        self.start_time = None
        self.end_time = None
        
        # Risk management
        self.portfolio_value = 0.0
        self.available_buying_power = 0.0
        
        self.logger.info(f"Strategy '{self.config.name}' initialized")
    
    def _create_trading_client(self) -> TradingClient:
        """Create Alpaca trading client."""
        return TradingClient(
            api_key=self.app_config.alpaca.api_key,
            secret_key=self.app_config.alpaca.secret_key,
            paper=self.app_config.is_paper_trading
        )
    
    def _create_data_client(self) -> StockHistoricalDataClient:
        """Create Alpaca data client."""
        return StockHistoricalDataClient(
            api_key=self.app_config.alpaca.api_key,
            secret_key=self.app_config.alpaca.secret_key
        )
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate trading signals based on market data.
        
        Args:
            data: Market data as DataFrame
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def validate_signal(self, signal: TradingSignal) -> bool:
        """
        Validate a trading signal before execution.
        
        Args:
            signal: Trading signal to validate
            
        Returns:
            True if signal is valid, False otherwise
        """
        pass
    
    def start(self) -> None:
        """Start the strategy execution."""
        if self.state != StrategyState.INITIALIZED:
            raise ValueError(f"Strategy must be initialized before starting. Current state: {self.state}")
        
        self.state = StrategyState.RUNNING
        self.start_time = datetime.now()
        self.logger.info(f"Strategy '{self.config.name}' started")
        
        # Update portfolio information
        self._update_portfolio_info()
    
    def stop(self) -> None:
        """Stop the strategy execution."""
        self.state = StrategyState.STOPPED
        self.end_time = datetime.now()
        self.logger.info(f"Strategy '{self.config.name}' stopped")
        
        # Log final performance
        self._log_performance_summary()
    
    def pause(self) -> None:
        """Pause the strategy execution."""
        if self.state == StrategyState.RUNNING:
            self.state = StrategyState.PAUSED
            self.logger.info(f"Strategy '{self.config.name}' paused")
    
    def resume(self) -> None:
        """Resume the strategy execution."""
        if self.state == StrategyState.PAUSED:
            self.state = StrategyState.RUNNING
            self.logger.info(f"Strategy '{self.config.name}' resumed")
    
    def process_signals(self, signals: List[TradingSignal]) -> None:
        """
        Process trading signals and execute trades.
        
        Args:
            signals: List of trading signals to process
        """
        if self.state != StrategyState.RUNNING:
            return
        
        for signal in signals:
            try:
                if self.validate_signal(signal):
                    self._execute_signal(signal)
            except Exception as e:
                self.logger.error(f"Error processing signal {signal}: {e}")
    
    def _execute_signal(self, signal: TradingSignal) -> None:
        """
        Execute a validated trading signal.
        
        Args:
            signal: Trading signal to execute
        """
        # Check daily trade limit
        if self._check_daily_trade_limit():
            self.logger.warning("Daily trade limit reached")
            return
        
        # Check risk management
        if not self._check_risk_management(signal):
            self.logger.warning(f"Risk management check failed for signal: {signal}")
            return
        
        # Execute the trade
        if signal.signal_type in [SignalType.BUY]:
            self._execute_buy_order(signal)
        elif signal.signal_type in [SignalType.SELL, SignalType.EXIT]:
            self._execute_sell_order(signal)
    
    def _execute_buy_order(self, signal: TradingSignal) -> None:
        """Execute a buy order."""
        try:
            quantity = signal.quantity or self._calculate_position_size(signal)
            
            order_request = MarketOrderRequest(
                symbol=signal.symbol,
                qty=quantity,
                side=OrderSide.BUY,
                time_in_force=TimeInForce.DAY
            )
            
            order = self.trading_client.submit_order(order_request)
            
            # Update position tracking
            if signal.symbol not in self.positions:
                self.positions[signal.symbol] = Position(
                    symbol=signal.symbol,
                    quantity=quantity,
                    entry_price=signal.price or 0.0,
                    strategy=self.config.name
                )
            else:
                # Average down/up
                existing_pos = self.positions[signal.symbol]
                total_quantity = existing_pos.quantity + quantity
                avg_price = ((existing_pos.entry_price * existing_pos.quantity) + 
                           (signal.price * quantity)) / total_quantity
                existing_pos.quantity = total_quantity
                existing_pos.entry_price = avg_price
            
            # Log the trade
            log_trade_event(
                trade_type="stock",
                symbol=signal.symbol,
                action="buy",
                quantity=quantity,
                price=signal.price,
                strategy=self.config.name
            )
            
            self._update_trade_stats(True)  # Assume successful for now
            
        except Exception as e:
            self.logger.error(f"Error executing buy order for {signal.symbol}: {e}")
    
    def _execute_sell_order(self, signal: TradingSignal) -> None:
        """Execute a sell order."""
        try:
            if signal.symbol not in self.positions:
                self.logger.warning(f"No position found for {signal.symbol}")
                return
            
            position = self.positions[signal.symbol]
            quantity = signal.quantity or position.quantity
            
            order_request = MarketOrderRequest(
                symbol=signal.symbol,
                qty=min(quantity, position.quantity),
                side=OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )
            
            order = self.trading_client.submit_order(order_request)
            
            # Update position
            position.quantity -= quantity
            if position.quantity <= 0:
                del self.positions[signal.symbol]
            
            # Log the trade
            log_trade_event(
                trade_type="stock",
                symbol=signal.symbol,
                action="sell",
                quantity=quantity,
                price=signal.price,
                strategy=self.config.name
            )
            
            self._update_trade_stats(True)  # Assume successful for now
            
        except Exception as e:
            self.logger.error(f"Error executing sell order for {signal.symbol}: {e}")
    
    def _calculate_position_size(self, signal: TradingSignal) -> int:
        """Calculate position size based on strategy configuration."""
        if signal.price is None or signal.price <= 0:
            return 0
        
        # Calculate based on percentage of portfolio
        target_value = self.portfolio_value * self.config.position_size
        quantity = int(target_value / signal.price)
        
        # Apply risk management
        max_risk_value = self.portfolio_value * self.config.risk_per_trade
        max_quantity_by_risk = int(max_risk_value / (signal.price * self.config.stop_loss))
        
        return min(quantity, max_quantity_by_risk)
    
    def _check_daily_trade_limit(self) -> bool:
        """Check if daily trade limit is reached."""
        today = datetime.now().date()
        
        if self.last_trade_date != today:
            self.daily_trades = 0
            self.last_trade_date = today
        
        return self.daily_trades >= self.config.max_daily_trades
    
    def _check_risk_management(self, signal: TradingSignal) -> bool:
        """Check risk management constraints."""
        # Check maximum positions
        if len(self.positions) >= self.config.max_positions:
            if signal.signal_type == SignalType.BUY and signal.symbol not in self.positions:
                return False
        
        # Check available buying power
        if signal.signal_type == SignalType.BUY:
            estimated_cost = (signal.price or 0) * (signal.quantity or self._calculate_position_size(signal))
            if estimated_cost > self.available_buying_power:
                return False
        
        return True
    
    def _update_portfolio_info(self) -> None:
        """Update portfolio information from Alpaca."""
        try:
            account = self.trading_client.get_account()
            self.portfolio_value = float(account.portfolio_value)
            self.available_buying_power = float(account.buying_power)
        except Exception as e:
            self.logger.error(f"Error updating portfolio info: {e}")
    
    def _update_trade_stats(self, successful: bool) -> None:
        """Update trade statistics."""
        self.total_trades += 1
        self.daily_trades += 1
        
        if successful:
            self.winning_trades += 1
        else:
            self.losing_trades += 1
    
    def _log_performance_summary(self) -> None:
        """Log strategy performance summary."""
        if self.total_trades > 0:
            win_rate = (self.winning_trades / self.total_trades) * 100
            
            log_strategy_performance(
                strategy_name=self.config.name,
                metric_type="win_rate",
                metric_value=win_rate,
                period="total"
            )
            
            log_strategy_performance(
                strategy_name=self.config.name,
                metric_type="total_trades",
                metric_value=self.total_trades,
                period="total"
            )
    
    def get_historical_data(
        self,
        symbol: str,
        timeframe: TimeFrame = TimeFrame.Day,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None
    ) -> pd.DataFrame:
        """
        Get historical data for a symbol.
        
        Args:
            symbol: Trading symbol
            timeframe: Data timeframe
            start: Start date
            end: End date
            limit: Maximum number of bars
            
        Returns:
            Historical data as DataFrame
        """
        try:
            if start is None:
                start = datetime.now() - timedelta(days=365)
            if end is None:
                end = datetime.now()
            
            request = StockBarsRequest(
                symbol_or_symbols=symbol,
                timeframe=timeframe,
                start=start,
                end=end,
                limit=limit
            )
            
            bars = self.data_client.get_stock_bars(request)
            return bars.df
            
        except Exception as e:
            self.logger.error(f"Error fetching historical data for {symbol}: {e}")
            return pd.DataFrame()
    
    def get_current_positions(self) -> Dict[str, Position]:
        """Get current strategy positions."""
        return self.positions.copy()
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get strategy performance metrics."""
        total_unrealized_pnl = sum(pos.unrealized_pnl for pos in self.positions.values())
        
        return {
            "strategy_name": self.config.name,
            "state": self.state.value,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": (self.winning_trades / self.total_trades * 100) if self.total_trades > 0 else 0,
            "current_positions": len(self.positions),
            "total_unrealized_pnl": total_unrealized_pnl,
            "portfolio_value": self.portfolio_value,
            "daily_trades": self.daily_trades,
            "start_time": self.start_time,
            "end_time": self.end_time,
        }
    
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(name='{self.config.name}', state='{self.state.value}')>" 